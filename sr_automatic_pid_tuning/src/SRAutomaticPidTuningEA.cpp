/** -*- mode: c++; c-indent-level: 4; c++-member-init-indent: 8; comment-column: 35; -*-

The above line is usefulin Emacs-like editors
 */

/*
Template for creating a new representation in EO
================================================

This is the template main file.
It includes all other files that have been generated by the script create.sh
so it is the only file to compile.

In case you want to build up a separate library for your new Evolving Object,
you'll need some work - follow what's done in the src/ga dir, used in the
main file BitEA in tutorial/Lesson4 dir.
Or you can wait until we do it :-)
*/

// Miscellaneous include and declaration
#include <iostream>
using namespace std;

#include <ros/ros.h>

#include "sr_movements/movement_from_image.hpp"
#include "sr_movements/movement_publisher.hpp"

// eo general include
#include <eo>
// the real bounds (not yet in general eo include)
#include <utils/eoRealVectorBounds.h>

// include here whatever specific files for your representation
// Basically, this should include at least the following

/** definition of representation:
 * class eoSRAutomaticPidTuning MUST derive from EO<FitT> for some fitness
 */
#include "sr_automatic_pid_tuning/eoSRAutomaticPidTuning.h"

/** definition of initialisation:
 * class eoSRAutomaticPidTuningInit MUST derive from eoInit<eoSRAutomaticPidTuning>
 */
#include "sr_automatic_pid_tuning/eoSRAutomaticPidTuningInit.h"

/** definition of evaluation:
 * class eoSRAutomaticPidTuningEvalFunc MUST derive from eoEvalFunc<eoSRAutomaticPidTuning>
 * and should test for validity before doing any computation
 * see tutorial/Templates/evalFunc.tmpl
 */
#include "sr_automatic_pid_tuning/eoSRAutomaticPidTuningEvalFunc.h"

/** definitions of operators: write as many classes as types of operators
 * and include them here. In this simple example,
 * one crossover (2->2) and one mutation (1->1) operators are used
 */
#include "sr_automatic_pid_tuning/eoSRAutomaticPidTuningQuadCrossover.h"
#include "sr_automatic_pid_tuning/eoSRAutomaticPidTuningMutation.h"

/* and (possibly) your personal statistics */
#include "sr_automatic_pid_tuning/eoSRAutomaticPidTuningStat.h"

// GENOTYPE   eoSRAutomaticPidTuning ***MUST*** be templatized over the fitness

//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
// START fitness type: double or eoMaximizingFitness if you are maximising
//                     eoMinimizingFitness if you are minimising
typedef eoMinimizingFitness MyFitT ;	// type of fitness
// END fitness type
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

// Then define your EO objects using that fitness type
typedef eoSRAutomaticPidTuning<MyFitT> Indi;      // ***MUST*** derive from EO


// Use existing modules to define representation independent routines

// how to initialise the population
// it IS representation independent if an eoInit is given
#include <do/make_pop.h>
eoPop<Indi >&  make_pop(eoParser& _parser, eoState& _state, eoInit<Indi> & _init)
{
  return do_make_pop(_parser, _state, _init);
}

// the stopping criterion
#include <do/make_continue.h>
eoContinue<Indi>& make_continue(eoParser& _parser, eoState& _state, eoEvalFuncCounter<Indi> & _eval)
{
  return do_make_continue(_parser, _state, _eval);
}

// outputs (stats, population dumps, ...)
#include <do/make_checkpoint.h>
eoCheckPoint<Indi>& make_checkpoint(eoParser& _parser, eoState& _state, eoEvalFuncCounter<Indi>& _eval, eoContinue<Indi>& _continue)
{
  return do_make_checkpoint(_parser, _state, _eval, _continue);
}

// evolution engine (selection and replacement)
#include <do/make_algo_scalar.h>
eoAlgo<Indi>&  make_algo_scalar(eoParser& _parser, eoState& _state, eoEvalFunc<Indi>& _eval, eoContinue<Indi>& _continue, eoGenOp<Indi>& _op, eoDistance<Indi> *_dist = NULL)
{
  return do_make_algo_scalar(_parser, _state, _eval, _continue, _op, _dist);
}

// simple call to the algo. stays there for consistency reasons
// no template for that one
#include <do/make_run.h>
// the instantiating fitnesses
#include <eoScalarFitness.h>
void run_ea(eoAlgo<Indi>& _ga, eoPop<Indi>& _pop)
{
  do_run(_ga, _pop);
}

// checks for help demand, and writes the status file
// and make_help; in libutils
void make_help(eoParser & _parser);

// now use all of the above, + representation dependent things
int main(int argc, char* argv[])
{
  ros::init(argc, argv, "sr_automatic_pid_tuning");
  ros::AsyncSpinner spinner(1);
  spinner.start();
  try
  {
    eoParser parser(argc, argv);  // for user-parameter reading

    eoState state;    // keeps all things allocated

    // The fitness
    //////////////
    eoSRAutomaticPidTuningEvalFunc<Indi> plainEval/* (varType  _anyVariable) */;
    // turn that object into an evaluation counter
    eoEvalFuncCounter<Indi> eval(plainEval);

    std::string joint = "ffj3";
    joint = parser.createParam(joint, "joint", "Joint you want to tune", 'j', "Automatic PID Tuning" ).value();
    std::cout << " Will tune joint: "<< joint <<std::endl;

    std::string cont_type = "motor";
    cont_type = parser.createParam(cont_type, "controller", "Type of controller you want to tune: motor, position, mixed, velocity or gazebo", 'c', "Automatic PID Tuning" ).value();
    int controller_type = 0;

    ROS_INFO_STREAM("Tuning the " << cont_type << " controllers.");
    if( cont_type.compare("motor") == 0)
    {
      controller_type = MOTOR_CONTROLLER;
    }
    else
    {
      if( cont_type.compare("position") == 0 )
        controller_type = POSITION_CONTROLLER;
      else
      {
        if( cont_type.compare("mixed") == 0)
          controller_type = MIXED_CONTROLLER;
        else
        {
          if( cont_type.compare("velocity") == 0)
            controller_type = VELOCITY_CONTROLLER;
          else
          {
            if( cont_type.compare("gazebo") == 0)
              controller_type = GAZEBO_CONTROLLER;
            else
            {
              ROS_ERROR_STREAM("Controller type not recognized: " << cont_type);
            }
          }
        }
      }
    }


    ros::NodeHandle nh_tilde("~");
    std::vector<int> seed;

    XmlRpc::XmlRpcValue seed_tmp;

    if( !nh_tilde.getParam("starting_seed", seed_tmp) )
    {
      std::cout << "No Starting seed" << std::endl;
      // a genotype initializer
      seed.push_back(60);
      seed.push_back(25);
      seed.push_back(5);
      seed.push_back(1);
    }
    else
    {
      ROS_ASSERT(seed_tmp.getType() == XmlRpc::XmlRpcValue::TypeArray);
      for (int32_t i = 0; i < seed_tmp.size(); ++i)
      {
        ROS_ASSERT(seed_tmp[i].getType() == XmlRpc::XmlRpcValue::TypeInt);
        seed.push_back( static_cast<int>(seed_tmp[i]) );
      }

      std::cout << "Starting seed provided: ";
      for( unsigned int i=0; i<seed.size(); ++i)
        std:: cout << seed[i] << " ";
    }
    std::cout << std::endl;


    XmlRpc::XmlRpcValue max_var_tmp;
    std::vector<int> max_variations;
    if( !nh_tilde.getParam("max_variations", max_var_tmp) )
    {
      std::cout << "No maximum variations provided" << std::endl;
      max_variations.push_back(500);
      max_variations.push_back(500);
      max_variations.push_back(500);
      max_variations.push_back(500);
    }
    else
    {
      ROS_ASSERT(max_var_tmp.getType() == XmlRpc::XmlRpcValue::TypeArray);
      for (int32_t i = 0; i < max_var_tmp.size(); ++i)
      {
        ROS_ASSERT(max_var_tmp[i].getType() == XmlRpc::XmlRpcValue::TypeInt);
        max_variations.push_back( static_cast<int>(max_var_tmp[i]) );
      }

      std::cout << "Max Variations: ";
      for( unsigned int i=0; i<max_variations.size(); ++i)
        std:: cout << max_variations[i] << " ";
    }

    //Setup the movement on which the tuning will run.
    std::string img_path;
    if( !nh_tilde.getParam("image_path", img_path) )
    {
      ROS_ERROR("No movement selected.");
      return -1;
    }
    shadowrobot::MovementFromImage mvt_im( img_path );

    double min, max, publish_rate;
    if( !nh_tilde.getParam("min", min) )
      min = 0.0;
    if( !nh_tilde.getParam("max", max) )
      max = 1.5;
    if( !nh_tilde.getParam("publish_rate", publish_rate) )
      publish_rate = 100.0;

    shadowrobot::MovementPublisher mvt_pub( min, max, publish_rate );
    mvt_pub.add_movement( mvt_im );

    eoSRAutomaticPidTuningInit<Indi> init( seed, max_variations, joint,
                                           mvt_pub, controller_type);
    // or, if you need some parameters, you might as well
    // - write a constructor of the eoSRAutomaticPidTuningInit that uses a parser
    // - call it from here:
    //        eoSRAutomaticPidTuningInit<Indi> init(parser);

    // if you want to do sharing, you'll need a distance.
    // see file utils/eoDistance.h
    //
    // IF you representation has an operator[]() double-castable,
    // then you can use for instance the quadratic distance (L2 norm)
    //    eoQuadDistance<Indi> dist;
    // or the Hamming distance (L1 norm)
    // eoHammingDistance<Indi> dist;


    // Build the variation operator (any seq/prop construct)
    // here, a simple example with only 1 crossover (2->2, a QuadOp) and
    // one mutation, is given.
    // Hints to have choice among multiple crossovers and mutations are given

    // A (first) crossover (possibly use the parser in its Ctor)
    eoSRAutomaticPidTuningQuadCrossover<Indi> cross /* (eoParser parser) */;

    /////////////// Same thing for MUTATION

    // a (first) mutation   (possibly use the parser in its Ctor)
    eoSRAutomaticPidTuningMutation<Indi> mut /* (parser) */;

    // now encapsulate your crossover(s) and mutation(s) into an eoGeneralOp
    // so you can fully benefit of the existing evolution engines

    // First read the individual level parameters
    double pCross = parser.createParam(0.6, "pCross", "Probability of Crossover", 'C', "Variation Operators" ).value();
    // minimum check
    if ( (pCross < 0) || (pCross > 1) )
      throw runtime_error("Invalid pCross");

    double pMut = parser.createParam(0.1, "pMut", "Probability of Mutation", 'M', "Variation Operators" ).value();
    // minimum check
    if ( (pMut < 0) || (pMut > 1) )
      throw runtime_error("Invalid pMut");

    // now create the generalOp
    eoSGAGenOp<Indi> op(cross, pCross, mut, pMut);


    //// Now some representation-independent things
    //
    // You do not need to modify anything beyond this point
    // unless you want to add specific statistics to the checkpoint
    // in which case you should uncomment the corresponding block
    // and possibly modify the parameters in the stat object creation
    //////////////////////////////////////////////

    // initialize the population
    // yes, this is representation indepedent once you have an eoInit
    eoPop<Indi>& pop   = make_pop(parser, state, init);

    // stopping criteria
    eoContinue<Indi> & term = make_continue(parser, state, eval);
    // output
    eoCheckPoint<Indi> & checkpoint = make_checkpoint(parser, state, eval, term);


    // UNCOMMENT the following commented block if you want to add you stats

    // if uncommented, it is assumed that you will want to print some stat.
    // if not, then the following objects will be created uselessly - but what the heck!

    eoSRAutomaticPidTuningStat<Indi>   myStat;       // or maybe myStat(parser);
    checkpoint.add(myStat);
    // This one is probably redundant with the one in make_checkpoint, but w.t.h.
    eoIncrementorParam<unsigned> generationCounter("Gen.");
    checkpoint.add(generationCounter);
    // need to get the name of the redDir param (if any)
    std::string dirName =  parser.getORcreateParam(std::string("Res"), "resDir", "Directory to store DISK outputs", '\0', "Output - Disk").value() + "/";


    // those need to be pointers because of the if's
    eoStdoutMonitor *myStdOutMonitor;
    eoFileMonitor   *myFileMonitor;
    eoGnuplot1DMonitor *myGnuMonitor;

    // now check how you want to output the stat:
    bool printSRAutomaticPidTuningStat = parser.createParam(false, "coutSRAutomaticPidTuningStat", "Prints my stat to screen, one line per generation", '\0', "Automatic PID Tuning").value();
    bool fileSRAutomaticPidTuningStat = parser.createParam(false, "fileSRAutomaticPidTuningStat", "Saves my stat to file (in resDir", '\0', "Automatic PID Tuning").value();
    bool plotSRAutomaticPidTuningStat = parser.createParam(false, "plotSRAutomaticPidTuningStat", "On-line plots my stat using gnuplot", '\0', "Automatic PID Tuning").value();

    // should we write it on StdOut ?
    if (printSRAutomaticPidTuningStat)
    {
      myStdOutMonitor = new eoStdoutMonitor(false);
      // don't forget to store the memory in the state
      state.storeFunctor(myStdOutMonitor);
      // and of course to add the monitor to the checkpoint
      checkpoint.add(*myStdOutMonitor);
      // and the different fields to the monitor
      myStdOutMonitor->add(generationCounter);
      myStdOutMonitor->add(eval);
      myStdOutMonitor->add(myStat);
    }

    // first check the directory (and creates it if not exists already):
    if (fileSRAutomaticPidTuningStat || plotSRAutomaticPidTuningStat)
      if (! testDirRes(dirName, true) )
	throw runtime_error("Problem with resDir");

    // should we write it to a file ?
    if (fileSRAutomaticPidTuningStat)
    {
      // the file name is hard-coded - of course you can read
      // a string parameter in the parser if you prefer
      myFileMonitor = new eoFileMonitor(dirName + "myStat.xg");
      // don't forget to store the memory in the state
      state.storeFunctor(myFileMonitor);
      // and of course to add the monitor to the checkpoint
      checkpoint.add(*myFileMonitor);
      // and the different fields to the monitor
      myFileMonitor->add(generationCounter);
      myFileMonitor->add(eval);
      myFileMonitor->add(myStat);
    }

    // should we PLOT it on StdOut ? (one dot per generation, incremental plot)
    if (plotSRAutomaticPidTuningStat)
    {
      myGnuMonitor = new eoGnuplot1DMonitor(dirName+"plot_myStat.xg",minimizing_fitness<Indi>());
      // NOTE: you cand send commands to gnuplot at any time with the method
      // myGnuMonitor->gnuplotCommand(string)
      // par exemple, gnuplotCommand("set logscale y")

      // don't forget to store the memory in the state
      state.storeFunctor(myGnuMonitor);
      // and of course to add the monitor to the checkpoint
      checkpoint.add(*myGnuMonitor);
      // and the different fields to the monitor (X = eval, Y = myStat)
      myGnuMonitor->add(eval);
      myGnuMonitor->add(myStat);
    }

    // algorithm (need the operator!)
    eoAlgo<Indi>& ga = make_algo_scalar(parser, state, eval, checkpoint, op);
    // and the distance if you want to do sharing
    // eoAlgo<Indi>& ga = make_algo_scalar(parser, state, eval, checkpoint, op, &dist);

    ///// End of construction of the algorithm

    /////////////////////////////////////////
    // to be called AFTER all parameters have been read!!!
    make_help(parser);

    //// GO
    ///////
    // evaluate intial population AFTER help and status in case it takes time
    apply<Indi>(eval, pop);
    // if you want to print it out
    cout << "Initial Population\n";
    pop.sortedPrintOn(cout);
    cout << endl;

    run_ea(ga, pop); // run the ga

    cout << "Final Population\n";
    pop.sortedPrintOn(cout);
    cout << endl;

  }
  catch(exception& e)
  {
    cout << e.what() << endl;
  }


  return 0;
}

/* For the emacs weenies in the crowd.
Local Variables:
   c-basic-offset: 2
End:
*/
